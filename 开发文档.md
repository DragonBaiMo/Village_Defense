《开发总文档》Hypixel《进击的苦力怕》复刻 Demo（基于 Village Defense 魔改）

1. 项目总览

1.1 开发背景
客户（老板）需求是“复刻 Hypixel 的《进击的苦力怕》小游戏”，交付形态是一个可演示的 Demo 整包：插件本体 + 可用配置 + 权限与命令用法 + 使用说明；地图不纳入本阶段交付，但需要提供“地图点位如何配置”的能力与指引。为了控制成本与工期，约束为：少地图、不要排行榜、不要跨服/复杂对接，优先复用现成成熟方案。

1.2 问题定义与核心目标
问题定义：在 Minecraft 1.8.x（以 1.8.8 为主要目标环境）上实现一套“多通道防守 + 波次推进 + 中心 NPC 生命值 + 经济与商店升级 + 清晰 UI 提示”的小游戏玩法，且让后续开发/维护可以通过配置快速调参，而非反复改代码。
核心目标：

* 玩法闭环完整：能从进入游戏 → 开局 → 多波防守 → 胜负结算 → 回到大厅（或出场点）。
* 可配置、可运营：波次、怪物数量、商人血量、爆炸伤害比例、金币奖励与扣除、商店商品与价格等通过配置文件即可调整。
* 管理可控：权限清晰，管理员可设置点位、重载配置、强制开局/结束。
* AI 可执行：将需求拆成可以被代码 AI 从仓库层面逐步实现的任务卡，执行者只做“下载仓库/运行测试/提交改动”。

1.3 功能简要概述

* 4 条通道（Lane）刷怪：每条通道配置 spawn 点与终点（靠近中心 Trader）。
* Creeper 核心威胁：靠近 Trader 触发倒计时爆炸，不破坏地形，扣 Trader 血量比例。
* 波次系统：按 waveIndex 递增刷新，清波后间隔进入下一波。
* 经济与商店：击杀获得金币，死亡扣金币比例；波次间可购买武器/道具/特殊技能。
* UI：记分板/标题/聊天提示显示波次、Trader 血量、金币、倒计时等。
* 配置与权限：提供 creeperattack.yml（或 config.yml 区段）+ 权限节点 + 管理命令。

1.4 项目目标与预期达成效果

* 交付后，服务端管理员无需改代码即可搭建一套可演示的“进击的苦力怕”玩法：放入插件、启动生成配置、配置点位、开局即可体验。
* 交付后，老板能通过演示看到核心体验：多路来怪、中心目标会被炸、波次推进、商店升级、胜负明确。
* 交付后，后续扩展（更多怪种、更多商品、更多事件）有明确扩展点，不需要推倒重来。

1.5 适用场景及目标用户群体

* 适用场景：

  * 小游戏服 Demo 验证、功能演示、投标/展示。
  * 单服内小游戏区（非跨服）。
  * 需要“玩法可跑、可调参、可控权”的中小型私服。
* 目标用户：

  * 服主/管理员（需要配置与权限）。
  * 普通玩家（需要清晰 UI、可玩闭环）。
  * 二次开发者/AI（需要清晰模块边界与任务卡）。

────────────────────────────────────────

2. 模块功能结构

本项目以 Village Defense 为底座（Arena/State/Shop/Scoreboard 等已有模块），在其基础上增加或替换“Creeper Attack 模式”模块。下面按模块列出：功能描述、输入/输出、内部流程、依赖与约束。

2.1 模块：Arena（竞技场容器与生命周期）
功能描述：

* 管理一局游戏的全部实体与状态：玩家列表、敌人列表、Trader（Villager/NPC）、波次 index、计分板、商店管理器、刷怪管理器、目标管理器、地图恢复等。

输入/输出：

* 输入：竞技场配置（arenaId、世界/区域、spawn 点位、Trader 点位、Lane 点位、规则参数），玩家加入/离开事件。
* 输出：ArenaState 状态切换、实体生成与清理、对外查询接口（当前波次、Trader HP、玩家金币等）。

内部逻辑流程：

1. Arena 初始化：加载管理器（ShopManager / EnemySpawnManager / CreatureTargetManager / ScoreboardManager 等）。
2. Starting：满足人数后倒计时，准备 Trader 与 Lane 数据。
3. InGame：循环执行 spawn/glitch check、波次推进、胜负判定。
4. Ending/Restarting：结算、清理实体、回收资源、还原地图（如启用）。

模块依赖与执行约束：

* 依赖底座的 PluginArena / ArenaState 状态机。
* 依赖 Bukkit 主线程：实体生成、UI 更新必须在主线程。
* 初始化条件：配置完整（至少 Trader 点位与 4 条 Lane spawn）。否则拒绝开始并给出明确日志。

2.2 模块：Lane（通道定义与刷怪入口）
功能描述：

* 定义 4 条固定通道的“刷怪点 + 目标终点 + 可选路径节点”，支持将本波怪物分配到不同通道，形成“多路防守”的观感。

输入/输出：

* 输入：配置文件中的 lanes.lane1..lane4（world,x,y,z）、可选 pathNodes 列表。
* 输出：刷怪点 Location、目标 Location、用于导航/目标设置的数据结构。

内部逻辑流程（推荐）：

* 启动时解析 creeperattack.yml → 构建 List<Lane>。
* 每次刷怪：

  * lane = random(1..4) 或按权重轮询
  * spawn at lane.spawn
  * setTarget creature -> lane.pathEnd 或 Trader

模块依赖与执行约束：

* 依赖配置加载器（YAML）。
* 若 pathNodes 未实现导航，则最小实现为：直接将怪物目标设为 Trader 或 pathEnd，保证怪物有方向性。

2.3 模块：Wave（波次配置与推进）
功能描述：

* 定义每波刷怪数量、怪物构成、刷怪节奏、波次间隔，并提供“清波判定 → 下一波启动”的推进机制。

输入/输出：

* 输入：waves.max_waves、waves.interval_seconds、每波怪物数量增长规则、特定波次额外怪物（可选）。
* 输出：当前 waveIndex、spawn 指令列表、UI 提示（Wave Start/Wave End）。

内部逻辑流程：

1. waveStart：waveIndex++；发送提示；初始化本波目标 spawn 总量。
2. spawnLoop：按 tick/秒节奏分批生成（避免一次性刷爆服务器）。
3. waveClearCheck：当“本波生成完成”且“存活敌人数量=0”时判定清波。
4. interval：等待 interval_seconds，进入下一波。
5. winCheck：waveIndex 达到 max_waves → win。

模块依赖与执行约束：

* 依赖 EnemySpawnManager 或新的 CreeperSpawnManager。
* 清波判定依赖 Arena.enemies 列表维护准确。
* 必须考虑实体异常：敌人卡死/消失，应有 glitch 清理或超时兜底。

2.4 模块：EnemySpawnManager（刷怪实现与节流）
功能描述：

* 负责“什么时候刷、刷多少、刷到哪里”，并包含“刷怪节流（idle process）与卡怪检测”。底座已有 spawnGlitchCheck 与 idle 控制逻辑，可复用。

输入/输出：

* 输入：Arena 当前状态、waveIndex、Lane 列表、配置的刷怪策略。
* 输出：生成的 Creature 实体、加入 arena.enemies 列表、日志/调试输出。

内部逻辑流程（CreeperAttack 模式）：

* 每个 spawn tick：

  * if localIdleProcess>0: return
  * 计算本 tick 需生成的数量 n
  * for i in 1..n:

    * lane = pickLane()
    * type = pickMobType(waveIndex)（优先 Creeper）
    * spawn(type, lane.spawn)
    * tag mob metadata = arenaId + waveIndex + laneId
    * setTarget(mob, Trader 或 lane.pathEnd)
* 每隔固定周期执行 glitch check：

  * 清理 dead enemies
  * 对长时间位置不变的敌人 teleport 到随机 spawn，或直接 remove（需谨慎，优先 teleport）。

模块依赖与执行约束：

* 主线程执行实体操作。
* 需要兼容 1.8：避免使用高版本 API（属性系统、PersistentDataContainer 等）。
* 敌人目标设置依赖 CreatureTargetManager 或直接 creature.setTarget。

2.5 模块：Creeper爆炸机制（核心玩法差异点）
功能描述：

* Creeper 接近 Trader 半径时触发倒计时；倒计时结束未被击杀则爆炸，对 Trader 造成“最大血量百分比伤害”，不破坏地形。
* Creeper 不可击退，确保其威胁稳定。

输入/输出：

* 输入：Creeper 位置、Trader 位置、trader.radius、countdown_seconds、explosion_damage_percent。
* 输出：爆炸效果、Trader HP 减少、UI 提示、该 Creeper 移除。

内部逻辑流程（最小可用实现）：

1. 监听器每 tick 或每 5 ticks 扫描：

   * for each creeper in arena.enemies where type==CREEPER:

     * if distance(creeper, trader) <= radius and creeper not already counting:

       * set metadata “CA_COUNTDOWN_END = now + countdownSeconds”
2. 每 20 ticks 更新：

   * if now >= countdownEnd:

     * arena.traderHp -= maxHp * damagePercent
     * play explosion effect (createExplosion with power 0F / no block damage)
     * remove creeper
     * if traderHp<=0: endGame(LOSE)

模块依赖与执行约束：

* 需要一个 TraderHP 存储，不依赖原版 Villager 实体生命值（因为要按比例扣且避免其它伤害干扰）。
* 需要对 creeper 的 knockback 做处理：

  * 1.8 可通过 NMS 或 Attribute（若可用）设置 knockback resistance；若不稳定，则通过 EntityDamageByEntityEvent 对 knockback 进行补偿（例如每次受击后强制维持速度/目标），作为兼容兜底。
* 爆炸不得破坏地形：必须关闭 block damage。

2.6 模块：Trader（中心目标与生命值体系）
功能描述：

* Trader 是中心 NPC（可用 Villager 实体承载交互），具有独立的 maxHp/currentHp。
* 负责：胜负判定、商店入口、提示显示（血量警告）。

输入/输出：

* 输入：trader.max_health、爆炸伤害、heal_trader 商品效果、Trader 坐标。
* 输出：TraderHP 变化、UI 更新、游戏失败触发。

内部逻辑流程：

* gameStart：spawnTraderEntity；绑定 arenaId；设置不可移动/不可被常规方式杀死（可通过取消伤害事件）。
* onCreeperExplode：扣 TraderHP；更新血条/记分板；触发警告阈值提示（25%、10%）。
* onHeal：加血但不超过 maxHp。

模块依赖与执行约束：

* 需要拦截玩家误伤 Trader（避免乱刀砍死）。
* Trader 与 Shop 交互依赖 ShopManager（右键打开 GUI）。

2.7 模块：Economy（金币与扣款）
功能描述：

* 玩家击杀敌人获取金币；玩家死亡扣除金币比例；金币用于商店购买。
* Demo 不接 Vault/外部经济，使用“局内货币”即可。

输入/输出：

* 输入：kill_reward 表、death_penalty_percent、购买请求（商品、价格）。
* 输出：玩家金币余额变化、购买成功/失败提示。

内部逻辑流程：

* onMobDeath: if killer in arena: coins[killer]+=reward(type)
* onPlayerDeath: coins[player]=floor(coins[player]*(1-penaltyPercent))
* onBuy: if coins>=price then coins-=price; applyItemEffect() else deny

模块依赖与执行约束：

* 需要 PlayerSession（见第 3 章）存金币。
* 必须避免并发修改（Bukkit 事件仍在主线程，但要避免重复触发）。
* 断线重连策略：Demo 级别可选择“断线金币清零”或“断线回到大厅”。建议清晰说明。

2.8 模块：Shop（商店与商品效果）
功能描述：

* 波次间与游戏中（可配置）通过右键 Trader 打开商店 GUI。
* 商品分类：武器/防具/恢复/特殊技能。
* Demo 重点：商品少但合理，效果可用。

输入/输出：

* 输入：shop 配置（items、price、lore、cooldown、effectType）。
* 输出：给玩家物品、触发技能效果（冻结、治疗 Trader）、扣金币、提示。

内部逻辑流程：

* openShop(player): buildInventoryFromConfig()
* clickItem: validate state（是否允许购买、是否冷却）→ check coins → apply effect → close/refresh GUI

模块依赖与执行约束：

* GUI 点击事件必须判定 inventory holder 是本插件。
* 冷却需要 per-player 记录（map key: playerUUID+itemId）。
* 冻结 Creeper 技能：对一定范围 Creeper 设置 slow/停留（1.8 可用 PotionEffect SLOW 高等级或直接 setAI false（若存在），不稳定则用反复 teleport 回原地兜底）。

2.9 模块：UI（Scoreboard/Title/Chat）
功能描述：

* 将关键状态可视化：波次、TraderHP、金币、倒计时、提示。

输入/输出：

* 输入：arena waveIndex、traderHp、playerCoins、countdownSeconds。
* 输出：计分板行文本、标题/副标题、聊天消息、音效。

内部逻辑流程：

* 每秒刷新 Scoreboard（不要每 tick 刷，避免性能问题）。
* 关键事件触发 Title：waveStart、traderLowHp、gameEnd。
* 倒计时可只在 creeper 进入半径后对附近玩家提示（减少刷屏）。

模块依赖与执行约束：

* 1.8 Title API 可能需要兼容层（底座可能已有 MessageBuilder/VersionUtils）。
* 文案从 language.yml 读取，默认中文。

2.10 模块：Commands & Permissions（管理与操作）
功能描述：

* 提供一组最小必要命令用于配置点位与控制测试。

输入/输出：

* 输入：命令参数、执行者权限、玩家位置。
* 输出：写入配置（内存 + 文件）、返回提示信息、触发游戏状态变化。

命令集合（建议）：

* /ca help：显示命令帮助
* /ca reload：重载 creeperattack.yml 与语言
* /ca settrader：将当前坐标设为 Trader
* /ca setlane <1|2|3|4> spawn：将当前坐标设为该 Lane 的 spawn
* /ca setlane <1|2|3|4> end：将当前坐标设为该 Lane 的 end
* /ca forcestart：强制开始（用于测试）
* /ca forcestop：强制结束（用于测试）

权限节点（建议）：

* creeperattack.admin：允许所有 /ca 管理命令
* creeperattack.play：允许加入/离开（若复用原 join/leave，可保留原权限）

模块依赖与执行约束：

* 写配置文件必须做“同步落盘 + 失败提示”。
* 强制开局必须校验点位完整，否则拒绝执行并列出缺失项。

────────────────────────────────────────

3. 数据结构与状态管理

3.1 核心数据结构说明

3.1.1 ArenaContext（建议新增/封装）
用途：集中存放 CreeperAttack 模式新增的数据，避免把 Arena 类塞成垃圾场。
字段建议：

* arenaId: String
* lanes: List<Lane>（固定 4 条）
* traderEntity: Villager（或 Entity）
* traderMaxHp: int
* traderHp: int
* waveIndex: int
* waveMax: int
* nextWaveAt: long（毫秒）
* coins: Map<UUID, Integer>
* creeperCountdownEnd: Map<UUID, Long>（key 为 creeper UUID）
* shopCooldowns: Map<String, Long>（key=playerUUID:itemId）

3.1.2 Lane

* laneId: int(1..4)
* spawn: Location
* end: Location
* pathNodes: List<Location>（可选，Demo 可先为空）

3.1.3 WavePlan（可选）
如果希望波次规则更可配，建议抽象：

* waveIndex
* spawns: List<MobSpawnPlan>（每种怪数量、lane 分配策略、分批间隔）

3.2 状态生命周期管理

3.2.1 Arena 状态机（基于底座 ArenaState）

* LOBBY/WAITING：玩家可加入，等待人数达到 minPlayers。
* STARTING：倒计时；校验配置；生成 Trader。
* IN_GAME：刷怪循环、倒计时爆炸、金币与商店。
* ENDING：胜负结算、奖励（可选）、提示。
* RESTARTING：清理实体、回收资源、重置变量、传送玩家回起点。

3.2.2 TraderHP 生命周期

* 创建时机：STARTING 进入时创建，初始化 traderHp=traderMaxHp。
* 变更时机：Creeper 爆炸、Heal 商品使用。
* 失效逻辑：GameEnd/Restarting 时清零并移除实体。

3.2.3 Creeper 倒计时生命周期

* 创建时机：creeper 进入 Trader 半径且未记录 countdown。
* 更新时机：每秒检查剩余时间，必要时提示。
* 失效逻辑：creeper 被击杀/移除；倒计时结束触发爆炸后移除记录；GameEnd 时清空 map。

3.2.4 Coins 生命周期

* 创建时机：玩家加入竞技场时 coins[uuid]=0（或继承上局，建议 Demo 直接清零）。
* 更新时机：击杀、死亡扣款、购买。
* 失效逻辑：玩家离开/断线/游戏结束时清除或重置（建议清除，避免残留）。

────────────────────────────────────────

4. 配置与扩展机制

4.1 是否支持外部配置与格式

* 支持外部配置：是。
* 格式：YAML（与 Village Defense 底座保持一致）。
* 文件建议：

  * creeperattack.yml：本模式核心配置（lane、trader、waves、economy、shop、ui）。
  * language.yml：中文文案与消息模板。
  * config.yml：底座通用项（本项目可在其中“禁用无关功能”）。

4.2 配置项说明（字段、含义、默认值、作用范围）

4.2.1 creeperattack.yml（推荐结构）

A. lanes

* lanes.lane1.spawn: string（world,x,y,z）默认空
* lanes.lane1.end: string（world,x,y,z）默认空
* lane2..lane4 同上
  作用范围：刷怪入口与目标终点。
  约束：4 条 lane 均必须配置 spawn 与 end，否则禁止 forcestart。

B. trader

* trader.location: string（world,x,y,z）默认空
* trader.max_health: int 默认 100
* trader.explosion_damage_percent: int 默认 10（每次爆炸扣最大血量百分比）
* trader.trigger_radius: double 默认 3.0（进入半径触发倒计时）
* trader.countdown_seconds: int 默认 3
* trader.invulnerable: boolean 默认 true（拦截常规伤害）
  作用范围：中心目标与爆炸机制。
  约束：location 必须存在。

C. waves

* waves.max_waves: int 默认 30
* waves.interval_seconds: int 默认 10（清波后等待）
* waves.spawn_per_wave.base: int 默认 8
* waves.spawn_per_wave.increase: int 默认 2（每波增加）
* waves.mob_mix.creeper_percent: int 默认 80（Creeper 占比）
* waves.batch_spawn.size: int 默认 4（每批刷几只）
* waves.batch_spawn.period_ticks: int 默认 20（每批间隔）
  作用范围：波次推进与刷怪节奏。
  约束：max_waves>0；批量刷怪防止卡服。

D. economy

* economy.kill_reward.creeper: int 默认 10
* economy.kill_reward.zombie: int 默认 3
* economy.death_penalty_percent: int 默认 33
* economy.enabled: boolean 默认 true
  作用范围：局内金币。
  约束：death_penalty_percent 0..100。

E. shop

* shop.enabled: boolean 默认 true
* shop.open_between_waves_only: boolean 默认 true
* shop.items.<itemId>.type: enum（WEAPON/ARMOR/CONSUMABLE/SPECIAL）
* shop.items.<itemId>.price: int
* shop.items.<itemId>.material: string（1.8 Material 名）
* shop.items.<itemId>.name: string
* shop.items.<itemId>.lore: list<string>
* shop.items.<itemId>.effect: object（按 type 解释）
* shop.items.<itemId>.cooldown_seconds: int 默认 0
  作用范围：GUI 商品与效果。
  约束：material 需兼容 1.8；price>=0。

F. ui

* ui.scoreboard.enabled: boolean 默认 true
* ui.scoreboard.refresh_seconds: int 默认 1
* ui.title.enabled: boolean 默认 true
* ui.chat.enabled: boolean 默认 true
* ui.trader_lowhp_thresholds: list<int> 默认 [25,10]
  作用范围：提示与展示。
  约束：刷新频率不应小于 1 秒。

4.2.2 config.yml（底座功能禁用项）
目的：减少无关功能干扰 Demo。
建议在 config.yml 中提供一个“CreeperAttackMode”开关或在启动时主动禁用：

* kits/powerups/party/leaderboard 等模块初始化不加载（实现层见第 10 章建议）。
  作用范围：减少 UI 与逻辑耦合，降低维护成本。

4.3 扩展机制设计

4.3.1 商品效果扩展（插件式注册）
设计：定义接口 ShopEffectHandler：

* boolean supports(effectType)
* void apply(player, arena, effectConfig)
  在启动时注册内置 handler：
* GIVE_ITEM（给物品）
* HEAL_TRADER（给 Trader 加血）
* FREEZE_CREEPERS（冻结范围 Creeper）
  后续扩展只需新增 handler 类与配置，不改 ShopManager 主流程。

4.3.2 波次策略扩展
设计：WaveSpawnStrategy 接口：

* List<MobSpawnPlan> buildPlans(waveIndex, config, arena)
  默认策略使用“base + increase + creeper_percent”。
  后续可以增加特定波次事件（例如 wave 10 增加僵尸、wave 20 增加速度 Creeper）。

4.3.3 配置热重载机制

* /ca reload：重载 creeperattack.yml 与 language.yml。
* 约束：热重载不影响正在进行的对局（建议只对下一局生效），避免一局中变更导致状态异常。
* 实现方式：重载后替换 ArenaContext 的“下一局模板”，当前局保持引用不变。

────────────────────────────────────────

5. 功能实现说明

5.1 本项目具体实现的功能点清单（本阶段）

* 单地图多通道（4 Lane）刷怪能力
* Creeper 接近 Trader 倒计时爆炸并扣 Trader 血量比例
* 波次推进与清波判定（含间隔）
* 局内金币：击杀奖励与死亡扣款
* 商店 GUI：购买武器/道具/至少 2 个特殊技能（冻结、治疗 Trader）
* UI：记分板显示（波次/TraderHP/金币），关键标题与聊天提示
* 管理命令与权限：点位设置、强制开局/结束、重载配置
* 默认配置文件生成与可运行性保证（不含地图，但配置结构可用）

5.2 每项功能的使用方式与触发条件

5.2.1 点位配置
触发：管理员执行 /ca settrader、/ca setlane。
结果：写入 creeperattack.yml，对下一次 /ca forcestart 生效。
注意：必须校验 world 存在、坐标可解析。

5.2.2 开局与波次
触发：玩家达到人数自动开局，或管理员 /ca forcestart。
运行：状态机进入 STARTING → IN_GAME，开始 waveIndex=1。
边界：若缺失 lane 或 trader 坐标，拒绝开始并输出缺失清单。

5.2.3 Creeper 倒计时爆炸
触发：Creeper 距离 Trader ≤ trigger_radius。
运行：开始 countdown_seconds 计时，结束后爆炸并扣 TraderHP。
失败处理：若 creeper 已死亡/被移除，倒计时取消并清理记录。

5.2.4 金币与商店购买
触发：击杀怪获得金币；死亡扣款；右键 Trader 打开商店。
运行：购买时校验余额与冷却；成功则扣款并发放效果。
失败处理：余额不足或冷却未到则提示原因，不扣款不发放。

5.3 使用中需特别注意的操作或边界条件

* 1.8 物品材质名与高版本不同：shop.material 必须以 1.8 为准。
* Creeper 击退免疫实现可能因版本差异需要 NMS 兼容层；若不做 NMS，必须提供“行为兜底”保证 Creeper 不会被无限顶开。
* 不能让爆炸破坏地形，否则地图会被炸烂，Demo 一局后就没法看。
* 不要把 scoreboard/提示每 tick 刷新，会直接让性能变难看。
* 热重载不建议影响正在进行的对局，避免出现“TraderHP 规则中途变更”。

────────────────────────────────────────

6. 关键流程图与交互逻辑

6.1 用户视角主流程（文本流程图）

入口：玩家进入服务器 → 加入小游戏 → 防守 → 波次推进 → 结算

流程：

1. 玩家执行加入（命令/菜单/招牌，取决于底座现有入口）
2. 等待人数达到 minPlayers
3. 倒计时开始，提示即将开局
4. 游戏开始：玩家在地图内就位；四条通道开始刷 Creeper
5. 玩家击杀怪获得金币
6. 某些 Creeper 接近中心 Trader：出现倒计时提示
7. 倒计时结束爆炸：TraderHP 下降，提示 Trader 受损
8. 当前波所有怪清完：提示“波次结束”，进入 10 秒商店期
9. 玩家右键 Trader 打开商店购买升级/道具
10. 下一波开始，重复 4-9
11. TraderHP 归零：失败结算并传送离场
12. 波次达到 max_waves：胜利结算并传送离场

6.2 系统视角主流程（状态机 + 关键节点）

状态机：WAITING → STARTING → IN_GAME → ENDING → RESTARTING → WAITING

WAITING：

* 事件：onPlayerJoinArena
* 条件：players >= minPlayers
* 动作：switch STARTING，start countdown task

STARTING：

* 动作：validateConfig()

  * require traderLocation
  * require lane1..lane4 spawn/end
* 动作：spawnTrader()，initTraderHP()
* 动作：initWaveIndex=0，schedule waveStart
* 条件：countdown==0 → switch IN_GAME

IN_GAME：

* 循环任务（每 tick/每秒组合）：

  * spawnGlitchCheck（底座复用）
  * waveSpawnerTick（按 batch period 生成）
  * creeperCountdownTick（检查距离与倒计时）
  * scoreboardRefresh（每秒）
  * win/lose check
* 关键条件：

  * traderHp<=0 → ENDING(LOSE)
  * waveIndex>=maxWaves && enemiesAlive==0 → ENDING(WIN)
  * waveClear → schedule next wave after interval

ENDING：

* 动作：announce result
* 动作：clearEntities
* 动作：teleportPlayersOut
* 动作：switch RESTARTING

RESTARTING：

* 动作：resetArenaContext
* 动作：map restore（若启用）
* switch WAITING

6.3 异常处理节点（必须出现）

* 配置缺失：禁止开始，明确打印缺失项。
* 刷怪异常：spawn 失败时记录日志并跳过该次 spawn，避免任务线程崩溃。
* Creeper 倒计时记录泄漏：GameEnd 时清空 countdown map。
* 玩家断线：从玩家列表移除；若人数为 0 可提前结束局并清理。
* Trader 实体丢失：定时校验 TraderEntity 是否存在，不存在则重生或直接判负（建议 Demo 直接判负并输出日志，避免隐性 bug）。

────────────────────────────────────────

7. 安全性与稳定性考量

7.1 多线程/并发一致性保障

* Bukkit 实体操作、UI 更新、配置写入建议全部在主线程执行。
* 若使用异步任务读取/解析配置，最终写入 ArenaContext 必须切回主线程，避免并发读写。
* coins、countdown、cooldowns 等 Map：

  * 若仅主线程访问，可用 HashMap。
  * 若存在异步访问，必须使用 ConcurrentHashMap 并统一入口，避免并发写问题。
* 强制规定：任何涉及 Entity 的集合（arena.enemies 等）只允许在主线程修改。

7.2 用户操作风险规避

* 越权访问：命令执行前必须 check permission。
* 误触：/ca forcestop 等危险命令必须二次确认（可选），或限定仅 console/OP。
* 防刷：商店购买要有冷却与状态校验（波次间购买、战斗中禁用可配置），避免玩家疯狂点击造成重复扣款/发放。
* Trader 保护：取消玩家对 Trader 的伤害事件，避免玩家误杀导致“非玩法失败”。

7.3 系统异常恢复与资源释放

* 资源释放清单（GameEnd 必做）：

  * remove 所有 spawned enemies（包括 glitched 清单）
  * remove trader entity
  * clear dropped items（如有）
  * cancel 所有 arena 相关任务（spawn task、scoreboard task、countdown task）
  * clear maps：coins/countdown/cooldowns
* 超时兜底：

  * 若某波刷怪生成完成后超过 X 秒仍未清完（怪卡到墙里），触发“清场”或 teleport 修复；优先 teleport 到 spawn，再不行 remove。
* 配置写入失败：必须回滚内存变更或标记“未落盘”，并提示管理员手工检查文件权限。

────────────────────────────────────────

8. 性能优化与可维护性设计

8.1 控制性能开销的具体设计

* 分批刷怪：waves.batch_spawn.size 与 period_ticks 控制瞬时实体生成峰值。
* UI 刷新频率：scoreboard 每秒刷新即可，不做每 tick。
* 距离检测：Creeper 倒计时扫描不要全世界扫描，只扫描 arena.enemies 中的 creeper；并且每 5 ticks 扫一次即可。
* glitch check：复用底座节奏（例如每 60 次 tick 累积触发），避免频繁 teleport。

8.2 模块间耦合解构策略

* 新增 CreeperAttackMode 层：

  * 不直接改底座每个类的内部细节，而是通过“策略注入/开关”替换刷怪策略、Trader 处理、UI 文案。
* 核心原则：

  * Arena 只负责生命周期与管理器挂载。
  * Spawn/Wave/Shop/Trader 各自独立，互相只通过 ArenaContext 交互。
* 配置解析集中化：ConfigService 统一读取与校验，避免在各模块散落 getConfig().get...。

8.3 支持版本升级或模块替换的接口规范

* 提供 VersionAdapter：

  * Title/ActionBar 发送
  * Knockback 抵抗设置
  * Material 解析（1.8 vs 高版本）
* 提供扩展接口：ShopEffectHandler、WaveSpawnStrategy。
* 未来替换底座：保留“CreeperAttackMode 的抽象层”，使逻辑不完全绑定 Village Defense。

────────────────────────────────────────

9. 测试设计建议

9.1 推荐覆盖的测试场景

主流程：

* T1：配置完整 → forcestart → wave1 正常刷怪 → 清波 → 商店期 → wave2 → 结束。
* T2：TraderHP 被炸到 0 → 触发失败 → 正常清理实体与任务。
* T3：达到 max_waves → 触发胜利 → 正常结算。

边界值：

* T4：缺失 lane3.end → /ca forcestart 被拒绝，输出缺失项。
* T5：death_penalty_percent=0 与 100 的两端行为正确。
* T6：爆炸伤害比例=1 与 50 的两端行为正确（扣血比例计算正确，不会变负数）。
* T7：batch_spawn.size=1 与 20 时服务器 TPS 变化可接受（观察日志与体验）。

异常路径：

* T8：Creeper 倒计时开始后被击杀 → 不爆炸、不扣 TraderHP，记录清理。
* T9：敌人卡死（位置不变）→ glitch check teleport 生效。
* T10：玩家在商店狂点 → 不会重复发放/重复扣款（冷却与点击去重正确）。
* T11：玩家断线/重连 → 金币与状态策略符合设计说明。
* T12：/ca reload 在 WAITING 状态生效，在 IN_GAME 状态不影响当前局（或明确策略一致）。

9.2 建议断言点与可自动化策略

* 单元层（可选）：

  * 配置解析与校验（ConfigService.validate）
  * 价格/金币结算（EconomyService）
* 集成层：

  * 在本地测试服通过脚本化命令驱动（Console 执行 /ca set… /ca forcestart），观察日志断言关键节点。
* 事件断言：

  * Creeper 进入半径 → countdown map 增加
  * countdown 结束 → TraderHP 减少
  * TraderHP<=0 → GameEnd 触发并清理

────────────────────────────────────────

10. 关键代码结构建议

以下给出结构草图与关键函数伪代码（不输出完整实现代码，只给 AI 执行者清晰骨架）。

10.1 包结构建议（在现有仓库基础上新增）

* plugily.projects.villagedefense.creeperattack

  * CreeperAttackMode（入口/注册）
  * config

    * CreeperAttackConfig
    * ConfigService（load/validate/save）
  * arena

    * ArenaContext
    * Lane
  * wave

    * WaveController
    * WaveSpawnStrategy（接口）
    * DefaultWaveSpawnStrategy
  * trader

    * TraderController
  * economy

    * EconomyService
  * shop

    * ShopController（封装底座 ShopManager）
    * effect

      * ShopEffectHandler（接口）
      * GiveItemEffect
      * HealTraderEffect
      * FreezeCreeperEffect
  * ui

    * UiController（scoreboard/title/chat）
  * command

    * CaCommandExecutor（/ca）
  * listener

    * CreeperProximityListener
    * MobDeathListener
    * PlayerDeathListener
    * TraderDamageBlockListener

10.2 关键函数伪代码

A. ConfigService.validate()

* input: creeperattack.yml parsed object
* output: ValidationResult { ok, missingFields[] }
* steps:

  1. check trader.location
  2. for lane in 1..4: check spawn and end
  3. check waves.max_waves > 0
  4. check economy.death_penalty_percent in [0..100]
  5. check shop items material exists in 1.8 Material map
  6. return result

B. WaveController.tick()

* precondition: arenaState == IN_GAME
* steps:

  1. if wave not started: startWave()
  2. if time to spawn batch: spawnBatch()
  3. if spawnedAllForWave and enemiesAlive==0: scheduleNextWave()
  4. if waveIndex==maxWaves and enemiesAlive==0 and spawnedAllForWave: win()

C. CreeperProximityListener.scan()

* steps:

  1. for each creeper in arenaEnemies where type==CREEPER:
  2. if distance(creeper, trader)<=radius:
     if countdown not exists: countdownEnd = now + countdownSeconds
  3. if countdown exists and now>=countdownEnd:
     explodeNoBlockDamage(); traderDamagePercent(); remove creeper; clear countdown
  4. if creeper dead: clear countdown

D. EconomyService.onMobKill()

* steps:

  1. if killer not in arena: return
  2. reward = killReward[mobType] default 0
  3. coins[killer]+=reward
  4. ui update

E. ShopController.onClick()

* steps:

  1. read itemId from clicked slot metadata
  2. cfg = shop.items[itemId]
  3. if open_between_waves_only and arena not in “SHOP_WINDOW”: deny
  4. if cooldown active: deny
  5. if coins<price: deny
  6. coins-=price
  7. handler = effectRegistry[cfg.effectType]
  8. handler.apply(player, arena, cfg.effect)
  9. set cooldown if needed
  10. ui update

10.3 外部库/框架推荐用法与原因

* Bukkit/Spigot API：实体、事件、GUI、任务调度均基于官方接口，确保 1.8 可运行。
* MinigamesBox/PlugilyProjects 底座：复用现有 ArenaState、ScoreboardManager、ShopManager、VersionUtils 等，降低重写成本。
* NMS（可选）：仅用于 1.8 Creeper 击退免疫这种“版本差异明显”的点，其他尽量避免 NMS。

────────────────────────────────────────

11. 外部依赖接口（如有）

本项目不引入外部 Web API，不做跨服与数据库强对接（按已确认范围）。外部依赖主要是“本地依赖与插件框架”：

11.1 Bukkit/Spigot API

* 事件接口：EntityDamageByEntityEvent、EntityDeathEvent、PlayerDeathEvent、PlayerInteractEntityEvent、InventoryClickEvent 等。
* 调用方式：通过 Listener 注册，主线程执行。
* 权限接口：player.hasPermission(permissionNode)。

11.2 PlugilyProjects / MinigamesBox（底座库）

* ArenaState 状态机与 PluginArena 基类
* VersionUtils/MessageBuilder 等兼容工具
* 调用方式：在底座约定的生命周期点挂载管理器与状态处理器。
  说明：这些类已在仓库源码中直接引用，属于项目构建时依赖的一部分，不涉及网络调用接口。

11.3 （可选）Vault

* 本阶段明确不接入 Vault 外部经济。若未来要与服务器经济统一，可在 EconomyService 抽象层增加 VaultAdapter，但不是当前交付内容。

────────────────────────────────────────

12. 开发注意事项

12.1 模块协作边界

* WaveController 只负责“本波刷怪计划与推进”，不直接处理 TraderHP。
* TraderController 只负责 TraderHP 与 Trader 交互入口，不直接做刷怪。
* EconomyService 只管理金币，不直接发放商店效果（由 ShopEffectHandler 发放）。
* UIController 不存业务数据，只展示 ArenaContext。
* ConfigService 是唯一写文件的模块，其他模块通过 ConfigService 提交修改请求，避免写配置逻辑散落。

12.2 工程限制与重点风险

* 1.8 兼容：Material 名称、Title 发送、属性系统都存在版本差异，必须封装 VersionAdapter。
* Creeper 击退免疫：这是体验关键点，也是最可能出现“版本坑”的点，必须有可验证的实现与兜底方案。
* 实体清理：小游戏最常见灾难是“结束不清理，越跑越卡”，必须把清理当第一优先级。
* 配置可用性：交付时 creeperattack.yml 必须带完整默认结构，服务端启动即可生成，管理员只需要填坐标即可开始测试。
* 文案与可理解性：language.yml 默认中文，提示信息不能堆术语，确保老板/测试者能看懂。